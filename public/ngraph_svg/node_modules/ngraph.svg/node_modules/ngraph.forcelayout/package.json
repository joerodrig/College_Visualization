{
  "name": "ngraph.forcelayout",
  "version": "0.0.12",
  "description": "Force directed graph drawing layout",
  "main": "index.js",
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/anvaka/ngraph.forcelayout.git"
  },
  "keywords": [
    "ngraph",
    "ngraphjs"
  ],
  "author": {
    "name": "Andrei Kashcha"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/anvaka/ngraph.forcelayout/issues"
  },
  "devDependencies": {
    "tap": "~0.4.4",
    "ngraph.graph": "~0.0.3",
    "ngraph.generators": "0.0.2",
    "benchmark": "~1.0.0"
  },
  "dependencies": {
    "ngraph.physics.primitives": "0.0.7",
    "ngraph.physics.simulator": "0.0.8"
  },
  "readme": "ngraph.forcelayout\n==========================\n[![Build Status](https://travis-ci.org/anvaka/ngraph.forcelayout.png?branch=master)](https://travis-ci.org/anvaka/ngraph.forcelayout)\n\nThis is a [force directed](http://en.wikipedia.org/wiki/Force-directed_graph_drawing) graph layouter in 2d. It is using quad tree as an n-body solver. This repository is part of [ngraph family](https://github.com/anvaka/ngraph), and operates on [`ngraph.graph`](https://github.com/anvaka/ngraph.graph) data structure. If you want to go the 3D space, please check out [`ngraph.forcelayout3d`](https://github.com/anvaka/ngraph.forcelayout3d)\n\n# API\n\nFirst of all it's worth to mention all force directed algorithms are iterative. We need to\nperform multiple iterations of an algorithm, before graph starts looking aesthetically pleasing.\n\nWith that in mind, the easiest way to make graph look nice is:\n\n``` js\n// graph is an instance of `ngraph.graph` object.\nvar layout = require('ngraph.forcelayout')(graph); \nfor (var i = 0; i < ITERATIONS_COUNT; ++i) {\n  layout.step();\n}\n\n// now we can ask layout where each node/link is best positioned:\ngraph.forEachNode(function(node) {\n  console.log(layout.getNodePosition(node.id));\n  // Node position is pair of x,y coordinates:\n  // {x: ... , y: ... }\n});\n\ngraph.forEachLink(function(link) {\n  console.log(layout.getLinkPosition(link.id));\n  // link position is a pair of two positions:\n  // { \n  //   from: {x: ..., y: ...}, \n  //   to: {x: ..., y: ...} \n  // }\n});\n```\n\n\nResult of `getNodePosition()`/`getLinkPosition()` will be always the same for the same node. This is true:\n\n``` js\n  layout.getNodePosition(1) === layout.getNodePosition(1);\n```\n\nReason for this is performance. If you are interested in storing positions somewhere else, you can do it and they still will be updated after each force directed layout iteration.\n\n## \"Pin\" node and initial position\n\nSometimes it's desirable to tell layout algorithm not to move certain nodes. This can be done with `pinNode()` method:\n\n``` js\n  var nodeToPin = graph.getNode(nodeId);\n  layout.pinNode(nodeToPin, true); // now layout will not move this node\n```\n\nIf you want to check whether node is pinned or not you can use `isNodePinned()` method. Here is an example how to toggle node pinning, without knowing it's original state:\n\n``` js\n  var node = graph.getNode(nodeId);\n  layout.pinNode(node, !layout.isNodePinned(node)); // toggle it\n```\n\nWhat if you still want to move your node according to some external factor (e.g. you have initial positions, or user drags pinned node)? To do this, call `setNodePosition()` method:\n\n``` js\n  layout.setNodePosition(nodeId, x, y);\n```\n\n## Monitoring changes\n\nLike many other algorithms in `ngraph` family, force layout monitors graph changes via [graph events](https://github.com/anvaka/ngraph.graph#listening-to-events). It keeps layout up to date whenever graph changes:\n\n``` js\n  var graph = require('ngraph.graph')(); // empty graph\n  var layout = require('ngraph.layout')(graph); // layout of empty graph\n  \n  graph.addLink(1, 2); // create node 1 and 2, and make link between them\n  layout.getNodePosition(1); // returns position. \n```\n\nIf you want to stop monitoring graph events, call `dispose()` method:\n``` js\n  layout.dispose();\n```\n  \n## Configuring physics\n\nSince this is force directed layout, sometimes it's desirable to adjust physics simulator. Please refer to [ngraph.physics.simulator](https://github.com/anvaka/ngraph.physics.simulator) to see source code and simulator parameters. Once you have instance of physics simulator you can pass it as a second argument to layout constructor:\n\n``` js\n// construct physics simulator:\nvar physics = require('ngraph.physics.simulator')({\n      springLength: 30,\n      springCoeff: 0.0008,\n      gravity: -1.2,\n      theta: 0.8,\n      dragCoeff: 0.02,\n      timeStep : 20\n    });\n\n// pass it as second argument to layout:\nvar layout = require('ngraph.forcelayout')(graph, physics);\n```\n\nYou can always get current physics simulator from layout by checking `layout.simulator` property. This is read only property.\n\n## Space occupied by graph\n\nFinally, it's often desirable to know how much space does our graph occupy. To quickly get bounding box use `getGraphRect()` method:\n\n``` js\n  var rect = layout.getGraphRect();\n  // rect.x1, rect.y1 - top left coordinates of bounding box\n  // rect.x2, rect.y2 - bottom right coordinates of bounding box\n```\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```\nnpm install ngraph.layout\n```\n\n# license\n\nMIT\n\n# Feedback?\n\nI'd totally love it! Please email me, open issue here, or [tweet](https://twitter.com/anvaka) to me\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/anvaka/ngraph.forcelayout",
  "_id": "ngraph.forcelayout@0.0.12",
  "dist": {
    "shasum": "b1c25edca0cd533772f38ff125ed2656c14320ff"
  },
  "_from": "ngraph.forcelayout@0.0.12",
  "_resolved": "https://registry.npmjs.org/ngraph.forcelayout/-/ngraph.forcelayout-0.0.12.tgz"
}
